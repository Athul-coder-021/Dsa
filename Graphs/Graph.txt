--------------------- Concepts -----------------------------------------

1. Total degree of a graph = 2*(no.of edges)
2. Directed graph has indegree and outdegree
3. In any graph traversal always carry visited array (******************IMP*******************)
4. If any question comes of 2d array and it can be solved by graph then assume each cell of 2d matrix
   as a vertex of graph . Graph vertex will be denoted by pair<int,int> .There will be no adjaceny matrix just traverse in all 8 directions
5. Think of multisource bfs , dfs when 2d array comes eg : (0/1 Matrix) (No.of distinct islands).
6. Cycle Concepts
    undirected use any of dfs or bfs
    directed use dfs with vis and pathvisited
    directe use bfs with khan's algorithm

7. Whenever you see something must be done before something thats when intution of topo sort should come.

---------------------- Adjacency Matrix representation ------------------

int main()
{
    int n, m;
    cin >> n >> m;
    // adjacency matrix for undirected graph
    // time complexity: O(n)
    int adj[n+1][n+1];
    for(int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;
        adj[u][v] = 1;
        adj[v][u] = 1  // this statement will be removed in case of directed graph
    }
    return 0;
}

---------------------------------------------------------------------------

----------------------- Adjacency List representation ---------------------

int main()
{
    int n, m;
    cin >> n >> m;
    // adjacency matrix for undirected graph
    // time complexity: O(n)
    int adj[n+1][n+1];
    for(int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;
        adj[u][v] = 1;
        adj[v][u] = 1  // this statement will be removed in case of directed graph
    }
    return 0;
}

------------------------------------------------------------------------------

--------------------------- BFS Traversal ------------------------------------

   vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        int vis[V] ={0};
        vis[0] = 1;
        queue<int>q;
        q.push(0);
        
        vector<int>bfs;
        
        while(!q.empty())
        {
            int node = q.front();
            q.pop();
            bfs.push_back(node);
            
            for(auto it: adj[node])
            {
                if(!vis[it])
                {
                    vis[it] =1;
                    q.push(it);
                }
            }
        }
        
        return bfs;
    }

------------------------------------------------------------------------------
--------------------------- DFS Traversal ------------------------------------

    private:
    void dfs(int node,vector<int> adj[],int vis[],vector<int>&ans)
    {
        vis[node] =1;
        ans.push_back(node);
        
        //traverse all its neighbours
        for(auto it : adj[node])
        {
            if(!vis[it])
            {
                dfs(it,adj,vis,ans);
            }
        }
    }
  public:
    // Function to return a list containing the DFS traversal of the graph.
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        vector<int>ans;
        int vis[V] = {0};
        int start = 0;
        dfs(start,adj,vis,ans);
        return ans;
    }

------------------------------------------------------------------------------

--------------------------- SHORTEST DIST IN UG (BFS)---------------------------

class Solution {
  public:
    vector<int> shortestPath(vector<vector<int>>& edges, int N,int M, int src){
        vector<int>adj[N];
        for(auto it :edges)
        {
            adj[it[0]].push_back(it[1]);
            adj[it[1]].push_back(it[0]);
        }
        
        int dist[N];
        for(int i =0;i<N;i++)
        {
            dist[i] = 1e9;
        }
        dist[src] =0;
        queue<int>q;
        q.push(src);
        while(!q.empty())
        {
            int node = q.front();
            q.pop();
            for(auto it:adj[node])
            {
                if(dist[node]+1<dist[it])
                {
                    dist[it] = 1+dist[node];
                    q.push(it);
                }
            }
        }
        
        vector<int>ans(N,-1);
        for(int i =0;i<N;i++)
        {
            if(dist[i]!=1e9)
            {
                ans[i] = dist[i];
            }
        }
        return ans;
    }
};

--------------------------------------------------------------------------

----------------------- SHORTEST DIST IN DAG (DFS TOPO) ------------------

class Solution {
  private:
    void topoSort(int node, vector < pair < int, int >> adj[],
      int vis[], stack < int > & st) {
      //This is the function to implement Topological sort. 
      vis[node] = 1;
      for (auto it: adj[node]) {
        int v = it.first;
        if (!vis[v]) {
          topoSort(v, adj, vis, st);
        }
      }
      st.push(node);
    }
  public:
    vector < int > shortestPath(int N, int M, vector < vector < int >> & edges) {

      //We create a graph first in the form of an adjacency list.
      vector < pair < int, int >> adj[N];
      for (int i = 0; i < M; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        int wt = edges[i][2];
        adj[u].push_back({v, wt}); 
      }
      // A visited array is created with initially 
      // all the nodes marked as unvisited (0).
      int vis[N] = {
        0
      };
      //Now, we perform topo sort using DFS technique 
      //and store the result in the stack st.
      stack < int > st;
      for (int i = 0; i < N; i++) {
        if (!vis[i]) {
          topoSort(i, adj, vis, st);
        }
      }
      //Further, we declare a vector ‘dist’ in which we update the value of the nodes’
      //distance from the source vertex after relaxation of a particular node.

      vector < int > dist(N);
      for (int i = 0; i < N; i++) {
        dist[i] = 1e9;
      }

      dist[0] = 0;
      while (!st.empty()) {
        int node = st.top();
        st.pop();

        for (auto it: adj[node]) {
          int v = it.first;
          int wt = it.second;

          if (dist[node] + wt < dist[v]) {
            dist[v] = wt + dist[node];
          }
        }
      }

      for (int i = 0; i < N; i++) {
        if (dist[i] == 1e9) dist[i] = -1;
      }
      return dist;
    }
};

--------------------------------------------------------------------------------------------

------------------------------ DIJSKTRA ALGO - PRIORITY QUEUE -----------------------------

Class Solution
{
	public:
	//Function to find the shortest distance of all the vertices
    //from the source vertex S.
    vector <int> dijkstra(int V, vector<vector<int>> adj[], int S)
    {
        // Code here
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;
        
        vector<int>dist(V);
        for(int i =0;i<V;i++)
        {
            dist[i] = 1e9;
        }
        
        dist[S] = 0;
        pq.push({0,S});//{dist,Node} 
        
        while(!pq.empty())
        {
            int dis = pq.top().first;
            int node = pq.top().second;
            pq.pop();
            
            for(auto it:adj[node])
            {
                int edgeWeight = it[1];
                int adjNode = it[0];
                
                if(dis+edgeWeight<dist[adjNode])
                {
                    dist[adjNode] = dis+edgeWeight;
                    pq.push({dist[adjNode],adjNode});
                }
            }
        }
        return dist;
    }
};

----------------------------------------------------------------------------------------------