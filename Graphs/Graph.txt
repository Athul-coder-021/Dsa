--------------------- Concepts -----------------------------------------

1. Total degree of a graph = 2*(no.of edges)
2. Directed graph has indegree and outdegree
3. In any graph traversal always carry visited array (******************IMP*******************)
4. If any question comes of 2d array and it can be solved by graph then assume each cell of 2d matrix
   as a vertex of graph . Graph vertex will be denoted by pair<int,int> .There will be no adjaceny matrix just traverse in all 8 directions
5. Think of multisource bfs , dfs when 2d array comes eg : (0/1 Matrix) (No.of distinct islands).
---------------------- Adjacency Matrix representation ------------------

int main()
{
    int n, m;
    cin >> n >> m;
    // adjacency matrix for undirected graph
    // time complexity: O(n)
    int adj[n+1][n+1];
    for(int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;
        adj[u][v] = 1;
        adj[v][u] = 1  // this statement will be removed in case of directed graph
    }
    return 0;
}

---------------------------------------------------------------------------

----------------------- Adjacency List representation ---------------------

int main()
{
    int n, m;
    cin >> n >> m;
    // adjacency matrix for undirected graph
    // time complexity: O(n)
    int adj[n+1][n+1];
    for(int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;
        adj[u][v] = 1;
        adj[v][u] = 1  // this statement will be removed in case of directed graph
    }
    return 0;
}

------------------------------------------------------------------------------

--------------------------- BFS Traversal ------------------------------------

   vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        int vis[V] ={0};
        vis[0] = 1;
        queue<int>q;
        q.push(0);
        
        vector<int>bfs;
        
        while(!q.empty())
        {
            int node = q.front();
            q.pop();
            bfs.push_back(node);
            
            for(auto it: adj[node])
            {
                if(!vis[it])
                {
                    vis[it] =1;
                    q.push(it);
                }
            }
        }
        
        return bfs;
    }

------------------------------------------------------------------------------
--------------------------- DFS Traversal ------------------------------------

    private:
    void dfs(int node,vector<int> adj[],int vis[],vector<int>&ans)
    {
        vis[node] =1;
        ans.push_back(node);
        
        //traverse all its neighbours
        for(auto it : adj[node])
        {
            if(!vis[it])
            {
                dfs(it,adj,vis,ans);
            }
        }
    }
  public:
    // Function to return a list containing the DFS traversal of the graph.
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        vector<int>ans;
        int vis[V] = {0};
        int start = 0;
        dfs(start,adj,vis,ans);
        return ans;
    }

------------------------------------------------------------------------------