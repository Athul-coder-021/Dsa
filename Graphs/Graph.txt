--------------------- Concepts -----------------------------------------

1. Total degree of a graph = 2*(no.of edges)
2. Directed graph has indegree and outdegree
3. In any graph traversal always carry visited array (******************IMP*******************)
4. If any question comes of 2d array and it can be solved by graph then assume each cell of 2d matrix
   as a vertex of graph . Graph vertex will be denoted by pair<int,int> .There will be no adjaceny matrix just traverse in all 8 directions
5. Think of multisource bfs , dfs when 2d array comes eg : (0/1 Matrix) (No.of distinct islands).
6. Cycle Concepts
    undirected use any of dfs or bfs
    directed use dfs with vis and pathvisited
    directe use bfs with khan's algorithm

7. Whenever you see something must be done before something thats when intution of topo sort should come.

---------------------- Adjacency Matrix representation ------------------

int main()
{
    int n, m;
    cin >> n >> m;
    // adjacency matrix for undirected graph
    // time complexity: O(n)
    int adj[n+1][n+1];
    for(int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;
        adj[u][v] = 1;
        adj[v][u] = 1  // this statement will be removed in case of directed graph
    }
    return 0;
}

---------------------------------------------------------------------------

----------------------- Adjacency List representation ---------------------

int main()
{
    int n, m;
    cin >> n >> m;
    // adjacency matrix for undirected graph
    // time complexity: O(n)
    int adj[n+1][n+1];
    for(int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;
        adj[u][v] = 1;
        adj[v][u] = 1  // this statement will be removed in case of directed graph
    }
    return 0;
}

------------------------------------------------------------------------------

--------------------------- BFS Traversal ------------------------------------

   vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        int vis[V] ={0};
        vis[0] = 1;
        queue<int>q;
        q.push(0);
        
        vector<int>bfs;
        
        while(!q.empty())
        {
            int node = q.front();
            q.pop();
            bfs.push_back(node);
            
            for(auto it: adj[node])
            {
                if(!vis[it])
                {
                    vis[it] =1;
                    q.push(it);
                }
            }
        }
        
        return bfs;
    }

------------------------------------------------------------------------------
--------------------------- DFS Traversal ------------------------------------

    private:
    void dfs(int node,vector<int> adj[],int vis[],vector<int>&ans)
    {
        vis[node] =1;
        ans.push_back(node);
        
        //traverse all its neighbours
        for(auto it : adj[node])
        {
            if(!vis[it])
            {
                dfs(it,adj,vis,ans);
            }
        }
    }
  public:
    // Function to return a list containing the DFS traversal of the graph.
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        vector<int>ans;
        int vis[V] = {0};
        int start = 0;
        dfs(start,adj,vis,ans);
        return ans;
    }

------------------------------------------------------------------------------

--------------------------- SHORTEST DIST IN UG (BFS)---------------------------

class Solution {
  public:
    vector<int> shortestPath(vector<vector<int>>& edges, int N,int M, int src){
        vector<int>adj[N];
        for(auto it :edges)
        {
            adj[it[0]].push_back(it[1]);
            adj[it[1]].push_back(it[0]);
        }
        
        int dist[N];
        for(int i =0;i<N;i++)
        {
            dist[i] = 1e9;
        }
        dist[src] =0;
        queue<int>q;
        q.push(src);
        while(!q.empty())
        {
            int node = q.front();
            q.pop();
            for(auto it:adj[node])
            {
                if(dist[node]+1<dist[it])
                {
                    dist[it] = 1+dist[node];
                    q.push(it);
                }
            }
        }
        
        vector<int>ans(N,-1);
        for(int i =0;i<N;i++)
        {
            if(dist[i]!=1e9)
            {
                ans[i] = dist[i];
            }
        }
        return ans;
    }
};

--------------------------------------------------------------------------

----------------------- SHORTEST DIST IN DAG (DFS TOPO) ------------------

class Solution {
  private:
    void topoSort(int node, vector < pair < int, int >> adj[],
      int vis[], stack < int > & st) {
      //This is the function to implement Topological sort. 
      vis[node] = 1;
      for (auto it: adj[node]) {
        int v = it.first;
        if (!vis[v]) {
          topoSort(v, adj, vis, st);
        }
      }
      st.push(node);
    }
  public:
    vector < int > shortestPath(int N, int M, vector < vector < int >> & edges) {

      //We create a graph first in the form of an adjacency list.
      vector < pair < int, int >> adj[N];
      for (int i = 0; i < M; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        int wt = edges[i][2];
        adj[u].push_back({v, wt}); 
      }
      // A visited array is created with initially 
      // all the nodes marked as unvisited (0).
      int vis[N] = {
        0
      };
      //Now, we perform topo sort using DFS technique 
      //and store the result in the stack st.
      stack < int > st;
      for (int i = 0; i < N; i++) {
        if (!vis[i]) {
          topoSort(i, adj, vis, st);
        }
      }
      //Further, we declare a vector ‘dist’ in which we update the value of the nodes’
      //distance from the source vertex after relaxation of a particular node.

      vector < int > dist(N);
      for (int i = 0; i < N; i++) {
        dist[i] = 1e9;
      }

      dist[0] = 0;
      while (!st.empty()) {
        int node = st.top();
        st.pop();

        for (auto it: adj[node]) {
          int v = it.first;
          int wt = it.second;

          if (dist[node] + wt < dist[v]) {
            dist[v] = wt + dist[node];
          }
        }
      }

      for (int i = 0; i < N; i++) {
        if (dist[i] == 1e9) dist[i] = -1;
      }
      return dist;
    }
};

--------------------------------------------------------------------------------------------

------------------------------ DIJSKTRA ALGO - PRIORITY QUEUE -----------------------------

Class Solution
{
	public:
	//Function to find the shortest distance of all the vertices
    //from the source vertex S.
    vector <int> dijkstra(int V, vector<vector<int>> adj[], int S)
    {
        // Code here
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;
        
        vector<int>dist(V);
        for(int i =0;i<V;i++)
        {
            dist[i] = 1e9;
        }
        
        dist[S] = 0;
        pq.push({0,S});//{dist,Node} 
        
        while(!pq.empty())
        {
            int dis = pq.top().first;
            int node = pq.top().second;
            pq.pop();
            
            for(auto it:adj[node])
            {
                int edgeWeight = it[1];
                int adjNode = it[0];
                
                if(dis+edgeWeight<dist[adjNode])
                {
                    dist[adjNode] = dis+edgeWeight;
                    pq.push({dist[adjNode],adjNode});
                }
            }
        }
        return dist;
    }
};

----------------------------------------------------------------------------------------------

-------------------------------- DIJSKTRA ALGO PATH ------------------------------------------
Copy code
public:
vector<int> shortestPath(int n, int m, vector<vector<int>>& edges) {
    vector<pair<int, int>> adj[n + 1];
    for (auto it : edges) {
        adj[it[0]].push_back({it[1], it[2]});
        adj[it[1]].push_back({it[0], it[2]});
    }

    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    vector<int> dist(n + 1, 1e9), parent(n + 1);
    for (int i = 1; i <= n; i++) {
        parent[i] = i;
    }
    dist[1] = 0;
    pq.push({0, 1});
    while (!pq.empty()) {
        auto it = pq.top();
        int node = it.second;
        int dis = it.first;
        pq.pop();

        for (auto it : adj[node]) {
            int adjNode = it.first;
            int edN = it.second;
            if (dis + edN < dist[adjNode]) {
                dist[adjNode] = dis + edN;
                pq.push({dis + edN, adjNode});
                parent[adjNode] = node;
            }
        }
    }

    // If no path exists
    if (dist[n] == 1e9) return {-1};

    // Reconstruct the path
    vector<int> path;
    int node = n;
    while (parent[node] != node) {
        path.push_back(node);
        node = parent[node];  // Correctly update the node to its parent
    }
    path.push_back(1);
    reverse(path.begin(), path.end());

    // Add the total weight of the path as the first element
    path.insert(path.begin(), dist[n]);
    return path;
}
------------------------------------------------------------------------------------

-------------------------- Number of shortest path --------------------------------

class Solution {
public:
    int countPaths(int n, vector<vector<int>>& roads) {
        // Why answer is so large? Give an estimation.
        // aprox 10k edges possible.
        // so 10k factorial answers possible.
        // Will dijkstra work?
        // The key lies in recording not only aa single path for each node 
        // but all the shortest paths.
        int mod = 1e9 + 7;
        vector<vector<pair<int, int>>> adj(n);
        for(auto& road : roads) {
            adj[road[0]].push_back({road[1], road[2]});
            adj[road[1]].push_back({road[0], road[2]});
        }

        vector<long> cost(n, LONG_MAX), ways(n, 0);
        cost[0] = 0;
        ways[0] = 1;
        priority_queue<pair<long, int>, vector<pair<long, int>>, greater<>> pq;        
        pq.push({0, 0});
        while(!pq.empty()) {
            // When a node is top of the min heap,
            // All the shortest paths to this node have been computed!
            auto [path_dist, node] = pq.top();
            pq.pop();

            for(auto& [adjNode, wt] : adj[node]) {
                // check if the path is shorter?
                
                if(path_dist + wt < cost[adjNode]) {
                    cost[adjNode] = (path_dist + wt);
                    // The ways the parent node has been reached is inherited!
                    ways[adjNode] = ways[node];
                    pq.push({cost[adjNode], adjNode});
                }

                // Is the path of same cost?
                else if(path_dist + wt == cost[adjNode]) {
                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;
                }
                
            }
        }
        return ways[n - 1] % mod;



    }
};

------------------------------------------------------------------------------------

----------------------------------- Bellman Ford algorithm -------------------------

class Solution {
  public:
    /*  Function to implement Bellman Ford
    *   edges: vector of vectors which represents the graph
    *   S: source vertex to start traversing graph with
    *   V: number of vertices
    */
    vector<int> bellman_ford(int V, vector<vector<int>>& edges, int S) {
        // Code here
        vector<int>dist(V,1e8);
        dist[S] = 0;
        for(int i =0;i<V-1;i++)
        {
            for(auto it:edges)
            {
                int u = it[0];
                int v = it[1];
                int wt = it[2];
                
                if(dist[u]!=1e8 && dist[u]+wt<dist[v])
                {
                    dist[v] = dist[u] + wt;
                }
            }
        }  
        //Nth relaxation to check negative cycle
        for(auto it :edges)
        {
            int u = it[0];
            int v = it[1];
            int wt = it[2];
            
            if(dist[u]!=1e8 && dist[u]+wt<dist[v])
            {
                return {-1};
            }
        }
        
        return dist;
    }
};
-------------------------------------------------------------------------------------------
------------------------------- Floyd Warshall algorithm ----------------------------------

#include <bits/stdc++.h>
using namespace std;


class Solution {
public:
	void shortest_distance(vector<vector<int>>&matrix) {
		int n = matrix.size();
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (matrix[i][j] == -1) {
					matrix[i][j] = 1e9;
				}
				if (i == j) matrix[i][j] = 0;
			}
		}

		for (int k = 0; k < n; k++) {
			for (int i = 0; i < n; i++) {
				for (int j = 0; j < n; j++) {
					matrix[i][j] = min(matrix[i][j],
					                   matrix[i][k] + matrix[k][j]);
				}
			}
		}




		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (matrix[i][j] == 1e9) {
					matrix[i][j] = -1;
				}
			}
		}
	}
};


int main() {

	int V = 4;
	vector<vector<int>> matrix(V, vector<int>(V, -1));
	matrix[0][1] = 2;
	matrix[1][0] = 1;
	matrix[1][2] = 3;
	matrix[3][0] = 3;
	matrix[3][1] = 5;
	matrix[3][2] = 4;

	Solution obj;
	obj.shortest_distance(matrix);

	for (auto row : matrix) {
		for (auto cell : row) {
			cout << cell << " ";
		}
		cout << endl;
	}

	return 0;
}

---------------------------------------------------------------------------------------
----------------------------------- Prims algo -> MST ---------------------------------

    int spanningTree(int V, vector<vector<int>> adj[])
    {
        // code here
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;
        
        vector<int>vis(V,0);//{wt,node}
        
        pq.push({0,0});
        int sum =0;
        while(!pq.empty())
        {
            auto it =pq.top();
            pq.pop();
            int node = it.second;
            int wt = it.first;
            
            if(vis[node] ==1)continue;//add it to the mst
            
            vis[node] =1;
            sum +=wt;
            for(auto it : adj[node])
            {
                int adjNode = it[0];
                int edW  = it[1];
                if(!vis[adjNode])
                {
                    pq.push({edW,adjNode});
                }
            }
            
        }
        return sum;
    }

-----------------------------------------------------------------------------------
------------------------------------ DISJOINT SET ALGO - BY RANK ------------------

#include <bits/stdc++.h>
using namespace std;
class DisjointSet {
    vector<int> rank, parent;
public:
    DisjointSet(int n) { // Constructor
        rank.resize(n + 1, 0);
        parent.resize(n + 1);
        for (int i = 0; i <= n; i++) {
            parent[i] = i;
        }
    }

    int findUPar(int node) {
        if (node == parent[node])
            return node;
        return parent[node] = findUPar(parent[node]);
    }

    void unionByRank(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (rank[ulp_u] < rank[ulp_v]) {
            parent[ulp_u] = ulp_v;
        }
        else if (rank[ulp_v] < rank[ulp_u]) {
            parent[ulp_v] = ulp_u;
        }
        else {
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }
};
int main() {
    DisjointSet ds(7);
    ds.unionByRank(1, 2);
    ds.unionByRank(2, 3);
    ds.unionByRank(4, 5);
    ds.unionByRank(6, 7);
    ds.unionByRank(5, 6);
    // if 3 and 7 same or not
    if (ds.findUPar(3) == ds.findUPar(7)) {
        cout << "Same\n";
    }
    else cout << "Not same\n";

    ds.unionByRank(3, 7);

    if (ds.findUPar(3) == ds.findUPar(7)) {
        cout << "Same\n";
    }
    else cout << "Not same\n";
    return 0;
}

------------------------------------------------------------------------------
------------------------------ DISJOINT SET ALGO - BY SIZE -------------------

#include <bits/stdc++.h>
using namespace std;
class DisjointSet {
    vector<int> rank, parent, size;
public:
    DisjointSet(int n) {
        rank.resize(n + 1, 0);
        parent.resize(n + 1);
        size.resize(n + 1);
        for (int i = 0; i <= n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    int findUPar(int node) {
        if (node == parent[node])
            return node;
        return parent[node] = findUPar(parent[node]);
    }

    void unionByRank(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (rank[ulp_u] < rank[ulp_v]) {
            parent[ulp_u] = ulp_v;
        }
        else if (rank[ulp_v] < rank[ulp_u]) {
            parent[ulp_v] = ulp_u;
        }
        else {
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }

    void unionBySize(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (size[ulp_u] < size[ulp_v]) {
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        }
        else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
};
int main() {
    DisjointSet ds(7);
    ds.unionBySize(1, 2);
    ds.unionBySize(2, 3);
    ds.unionBySize(4, 5);
    ds.unionBySize(6, 7);
    ds.unionBySize(5, 6);
    // if 3 and 7 same or not
    if (ds.findUPar(3) == ds.findUPar(7)) {
        cout << "Same\n";
    }
    else cout << "Not same\n";

    ds.unionBySize(3, 7);

    if (ds.findUPar(3) == ds.findUPar(7)) {
        cout << "Same\n";
    }
    else cout << "Not same\n";
    return 0;
}

-------------------------------------------------------------------------------
