--------------------- Concepts -----------------------------------------

1. Total degree of a graph = 2*(no.of edges)
2. Directed graph has indegree and outdegree
3. In any graph traversal always carry visited array (******************IMP*******************)
4. If any question comes of 2d array and it can be solved by graph then assume each cell of 2d matrix
   as a vertex of graph . Graph vertex will be denoted by pair<int,int> .There will be no adjaceny matrix just traverse in all 8 directions
5. Think of multisource bfs , dfs when 2d array comes eg : (0/1 Matrix) (No.of distinct islands).
6. Cycle Concepts
    undirected use any of dfs or bfs
    directed use dfs with vis and pathvisited
    directe use bfs with khan's algorithm

7. Whenever you see something must be done before something thats when intution of topo sort should come.

---------------------- Adjacency Matrix representation ------------------

int main()
{
    int n, m;
    cin >> n >> m;
    // adjacency matrix for undirected graph
    // time complexity: O(n)
    int adj[n+1][n+1];
    for(int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;
        adj[u][v] = 1;
        adj[v][u] = 1  // this statement will be removed in case of directed graph
    }
    return 0;
}

---------------------------------------------------------------------------

----------------------- Adjacency List representation ---------------------

int main()
{
    int n, m;
    cin >> n >> m;
    // adjacency matrix for undirected graph
    // time complexity: O(n)
    int adj[n+1][n+1];
    for(int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;
        adj[u][v] = 1;
        adj[v][u] = 1  // this statement will be removed in case of directed graph
    }
    return 0;
}

------------------------------------------------------------------------------

--------------------------- BFS Traversal ------------------------------------

   vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        int vis[V] ={0};
        vis[0] = 1;
        queue<int>q;
        q.push(0);
        
        vector<int>bfs;
        
        while(!q.empty())
        {
            int node = q.front();
            q.pop();
            bfs.push_back(node);
            
            for(auto it: adj[node])
            {
                if(!vis[it])
                {
                    vis[it] =1;
                    q.push(it);
                }
            }
        }
        
        return bfs;
    }

------------------------------------------------------------------------------
--------------------------- DFS Traversal ------------------------------------

    private:
    void dfs(int node,vector<int> adj[],int vis[],vector<int>&ans)
    {
        vis[node] =1;
        ans.push_back(node);
        
        //traverse all its neighbours
        for(auto it : adj[node])
        {
            if(!vis[it])
            {
                dfs(it,adj,vis,ans);
            }
        }
    }
  public:
    // Function to return a list containing the DFS traversal of the graph.
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        vector<int>ans;
        int vis[V] = {0};
        int start = 0;
        dfs(start,adj,vis,ans);
        return ans;
    }

------------------------------------------------------------------------------

------------------------------------ SHORTEST DIST IN UG (BFS)----------------

class Solution {
  public:
    vector<int> shortestPath(vector<vector<int>>& edges, int N,int M, int src){
        vector<int>adj[N];
        for(auto it :edges)
        {
            adj[it[0]].push_back(it[1]);
            adj[it[1]].push_back(it[0]);
        }
        
        int dist[N];
        for(int i =0;i<N;i++)
        {
            dist[i] = 1e9;
        }
        dist[src] =0;
        queue<int>q;
        q.push(src);
        while(!q.empty())
        {
            int node = q.front();
            q.pop();
            for(auto it:adj[node])
            {
                if(dist[node]+1<dist[it])
                {
                    dist[it] = 1+dist[node];
                    q.push(it);
                }
            }
        }
        
        vector<int>ans(N,-1);
        for(int i =0;i<N;i++)
        {
            if(dist[i]!=1e9)
            {
                ans[i] = dist[i];
            }
        }
        return ans;
    }
};

--------------------------------------------------------------------------